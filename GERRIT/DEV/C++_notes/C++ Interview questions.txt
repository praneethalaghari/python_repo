Differences between Malloc and calloc?
	Malloc will not initialize the allocated memory with 0's	-  Calloc will initialize the allocated memory with 0's
	Malloc is faster than calloc					-  Calloc is slower than Malloc because it needs to be initialized with 0
	Function is not parameterized					-  Calloc is parameterized i.e contains (no._of_elements,size)

What are the differences between calloc/malloc/realloc with new?
	New is an operator								- c/m/r are not operator,they are functions
	New calls constructor							- c/m/r will not call constructor
	With new only we can use delete					- c/m/r we can use only with free
	with new we cannot implement realloc            - we can do that via realloc function 
	  i.e we can extend/modify already allocate mem 
	New need not be typecasted explicity            - needs to be typecasted explicitly
	New can be operator overloaded                  - cannot be overloaded
	
	Note : realloc have the following structure - realloc(pointer,size)
	       if we subs the pointer with NULL and size not 0 then it is similar to malloc
		   if size passed is zero and ptr is not NLL then the call is similar to free
		   Thus with realloc we can simulate both malloc/free

    Note : if we try to free an already freed memory chunk then it will cause crash/segmentation fault		   
	
	
What is the difference between delete and free?
	delete is an operator							- free is a function
	delete calls destructor							- there is no call to destructor
	delete is called to objects created with new	- free is called if the memory is allocated via malloc,calloc,realloc
	
	
WHat are the differences between C++98 and C++11?
	Introduction to lambda expressions
	Introduction to final keyword
	Introduction to threading
	Introduction to smart pointers,auto,nullptr


	
How to open and close a file in C/C++ (file handling)?


What new does in object creation?
	When new operator is called then program context is switched from user mode to kernal mode
	The kernel will now check if memory is available i.e not it will throw bad allocate
	if available it will allocate and assign a pointer. // Similar to malloc

	
What happens if new cannot allocate new memory in heap?
	If we dont use nothrow then it will throw run time exception i.e bad_alloc
	if we use nothrow then it will return null pointer
	   i.e int *p = new(std::nothrow) int[4] // This will not throw bad_alloc exception but it will return null pointer
                                                But if we try to deference it result is undefined.. mostly it will crash	   

Why argument in copy constructor is const and &
	Argument is const because we want to make sure that the object which is being copied should not be accidentally changed during copying (i.e in copy constructor)
	Argument is & because it is (call by ref) it will avoid memory wastage if the object size is huge.. more over if we make it call by value by ommiting '&', then in turn, the copying
	   of actual paramters will have to be copied to formal paramters and it inturn calls copy constructor itself again.. so it will be an recursive infinite loop.

Can a private member of a method be modified outside without friend or inside the class?
	Yes it can be done using pointers. i.e fooling the compiler

    	class foo
		{int x;};

		int main()
		{
			foo f1;
			int *p = (int*)&f1;
			*p = 7;    // with this pointer we can change the value of private member x of f1 object
		}
	

Difference between assignment and copy constructor?
	The primary difference between the two is that..
		copy constructor will copy the contents of the object into a new place
			so it wont be a problem until unless there is a pointer
		Assignment overload operator will just create a reference to the original object
			so any variable changes it reflects in its reference object.
			
	So why we need both?
	    As explained assignment operator is called to copy contents to already existing object.
		Copy constructor is a special function which dont have return type and is called when copy args in pass by value
		          when an object is returned by value;when an exception is thrown

			
What are the different types of castings

     Casting   -  Implicit      Explicit
	 
	 Implicit  -  Demote(Down cast)        Promote(Up cast)
	 Explicit  -  Static	Dynamic		Const		reinterpret
	 
	 Const cast : 
			This type of casting will remove the constantness of the pointer.
			Eg :
					int a = 4;
					const int *b = &a;               // b is pointer to constant a
					int *c = const_cast<int*> b;     // Constantness of pointer b is not copied into pointer c
					*c = 9;                          // Valid


			However this fails
			Eg :
					const int a = 4;
					const int *b = &a;               // b is pointer to constant a
					int *c = const_cast<int*> b;     // Constantness of pointer b is not copied into pointer c
					*c = 9;                          // Invalid since even constantness is not carried to new pointer the variable itself is constant
					

     Reinterpret cast :
	        It is used to convert one pointer type to another pointer of any type
			This type of casting is force casting..
			i.e it will not check if the pointer type and the data to which it is pointing to is of same data or not.
			It does not have any return type
			
			     data_type *new_pointer_name = reinterpret_cast<data_type *>(pointer_to convert)
				 
	        Usage : int *p = new int(65);
			        char *q = reinterpret_cast<char *>(p);
					cout *q << endl                            // Outputs 'A' which is equalent to 65 in ascii
					
			Application : as shown above convert int* to char* to convert ascii-int/int-ascii or bool-int/int-bool
						  Used when we want to work on bits
						  
		
     Dynamic casting :
			This is primary used in down casting i.e to convert derived into base class object
			As the name suggests i.e dynamic, it is used in case of run time polymorphism(i.e only atleast one virtual function is used)
			If cast fails and new type is pointer type it will return null pointer
			if cast fails and new type is reference then it will throw exception (bad_cast)
			
	 
					
What is a functor?
	An object working as function is called functor
	it will overload '()' operator
	A functor is like function + operator
	A function is which maintains the state of variable similar to static
	Infact that is the advantage of having functor

Differences between Malloc and new?
	New is an operator         	-       Malloc is a library function
        New can be operator overloaded  -       Malloc cannot	
        New will initiate with 0s 	-       Malloc will have garbage values
	New will call constructor  	-       Malloc will not call constructor
	Memory deallocation-delete 	-       Malloc with free
	If no memory-exception-BadAlloc	-	Malloc will output null if it cannot allocate memory
        

How to free memory in C/C++ without free?
	In C we can free the memory allocated by calloc,malloc via realloc().
	realloc(ptr,0) - > This mean delete ptr;
	realloc(NULL,10) -> This mean malloc 10 bytes of memory (with junk values)
	each time we use realloc.. it copy the old contents of ptr into new locations(if increased) i.e deallocate the old memory and recreate the same in new place  

What happens if we 'delete this' in a function called by the object?
	This mean that program will try to delete the object which is calling the function.
	This is acceptable.. provided the object should not be used again.. after the function call.. if attempted it will cause segmentation fault.


What is Padding or structure alignment? Why do we need it?
	For any clock cycle processor will process a word (i.e a segment or frame) which is 4 bytes for 32 bit os and 8 bytes for 64 bit OS
	So if there are two datatypes(atleast one incomplete) in the frame.. it has to fetch next word to read complete data type.
	So for efficiency, if next data variable cannot fit into the frame.. it will assign the value in the memory location multiple of its data type data size.
	And the remaining elments are left which is called padding.  

What is Packing?
	If we dont want the efficiency in considering the frame.. i.e if memory is important than os overhead.. then we can avoid padding
	For this to happen just include #pragma pack(1) near the preprocessor directives

Calculate the padding in the given struct?

    int a;   //4
    char b;  //1
    bool c;  //1
	         //2 bits padding

	size : 8
	
	double a;   //8
    char b;  //1
    bool c;  //1
	         //last 6 bits padding

	size : 16           it will take the block size of highest datatype size..
	
	

What is the size of empty class/struct?
	A class is said to be empty class if it do not contain any data members.
        A class can be called as empty class if it contains only one function and that func is virual.
	
	Size of empty class is not 0 in either of the classes..
	In first case size of empty class is 1 byte to ensure different object have different memory spaces
	In second case size is 4 bytes/8 bytes based on 32 bit/64 bit.

	Note : Ofcourse class is not there in C, size of struct in C is 0 bytes.
	       where as C++ both struct/class is 1;
	
Difference between Mutex and Semaphore?
	Mutex is a locking mechanism		- 	Semaphore is signalling mechanism
	Mutex is used for sync in MT		- 	Semaphore can be used for both MP and MT
	Mutex possess owner ship		-	Semaphore do not possess ownership
	  i.e the one who locks is the owner	 	
	  
	Further Differentiate using producer-consumer problem
	

What is 'explicit' keyword ?
	If the class has only one variable i.e int x; and is initializing using paramtarized constructor.
	constructor is called when creating object lets say A a1(10);
	The same will be called if we do A a2 = 12; implicitly which can cause issues
	Inorder to prevent that we need to put explicit before constructor.
	Similary function taking the class A as paramter which have only one param i.e int, then even def is fun(A a); it can take fun(30)
    Hence this type of implicit constructors are not allowed with explicit	
	

What is 'extern' keyword ?
	extern is very much similar to global which ofcourse sometimes can be referred to globali.e both are declared outside all the functions.
	The primary application is if a variable is declared extern then the variable can be used in another file also..
	   like with following declaration extern int a;    // otherwise we cant use the same variable.. i.e a new variable is created if not declared extern
	It practivally means that variable 'a' is declared somewhere in some part of program.. so use it
	

Can we call constructor/Destructor explicitly?
	Yes we can..
	But care to be taken while calling destructor..
	as destructor may be called twice.. i.e explicit call and implicit call when object goes out of stack
	the double destructor call will be a problem if detructor has body which delete pointers,mutex etc..
	
	Eg Base();      Base().~Base()
	   In above case Base() will create a temporary object.destructor can only be called with object
	

What is Semaphore?

What is Mutex?

What happens if the virtual function is inherited privately using private inheritance?
	if suppose virtual function is inherited privately i.e if we use private inheritance when deriving derived class from base class.. then 
		there will be compiler error as follows : error: ‘Base’ is an inaccessible base of ‘Derived’ in the following line 
		  Base *ptr = new Derived;

Can we do this ?  int *p = new int[];
    No we should specify the number of bytes allocated.

Can we do this ? char p[] = "Hello";p[0] = 'M'
    Yes we need not specify the number of bytes allocated.
    Here we can do p[0] = "M"

Can we do this ? char *p = "Hello";p[0] = 'M'
    No we cannot do p[0] = "M" as it is equalent to const char* in C++
	
Can we have function overloading with same number of parameters and same datatypes?
	Yes it is possible.. with the help of constant qualifier..
	there are two cases in this... i. constantness of function return type	
								  ii. constantness of parameters in function definitions.
								  
	Constantness of function return type :
				void function foo(){}
				void function foo() const {}
				
				both the above functions are considered different.. and hence overloaded without compiletime error

				Test t1;t1.foo() will call first function
				const Test t2;t2.foo() will call second function
				
	Constantnes of paramters inside function definitions
	
	            void fun(const int i) {cout << "fun(const int) called "; } 
                void fun(int i){cout << "fun(int ) called " ;}

                const int i = 10; fun(i);   // This will yield compiler error

                because here we are passing argument by "pass by value"  so it cannot modify the actual paramter which is being passed.so it wont make any sense if i is passed as const or non const
                but it makes sense if we pass the argument which is ref or pointer.. then it will have impact on passing actual argument i.e it can(when not applied const) or cannot(when applied const) change actual paramter.so it makes difference
                hence it is valid..

                Eg : 

                    void fun(const char* i){cout << "const called ";} 
					void fun(char* i){cout << "non const called " ;} 
					
					const int *i = "Hello"; 
					fun(i);

					The above is valid
					
				
				
			    C++ allows functions to be overloaded on the basis of const-ness of parameters only if the const parameter is a reference or a pointer.
	
	
What is operator overloading and how to do it with dynamic memory pointer in it?



What is copy constructor and how to do it with dynamic memory pointer in it


Difference between List(linked list) and vector?
	Allocation of list is non contigous  - Allocation of vector is contigous
	Accessing an element is O(n)	     - Accesing an element is O(1)
	Insertion of element is O(1)         - Insertion of element is O(n) if it is not end else O(1)
	Need space for pointer too	         - Only need space for element
    Size is same as no of elements       - size is different capacity.. when size reaches capacity then capacity doubles and copies all elements to a new place 1,2,4,8,16,32..
	

What is the difference between returning int& and int ?
	Simple.. int&  -  (x3 = x2) = x1; is possible and not equal to x3 = x2 = x1;
			 int   -  (x3 = x2) = x1; is same as x3 = x2 = x1;
	
	
Why is it easy to access stack memory than heap memroy?
	Stack memory can be accessed faster compared to heap because of access pattern.
	For stack memory pointer/var(array) can be quickly accessed by incrementing/decrementing.as they are mostly contigous
	
	where as heap is little complex and mostly will not be contigous... so it will manage bookkeeping infomcation and it has overhead to read such data
	
	Note : heap address memory size is smaller in length than stack memory size
	
Why is stack size limited..? and heap size unlimited (i.e till the end of computer resources availble) ?

	One of the reason for this is... if suppose stack size is unlimited.. then it will be difficult to find out infinite recursive loops.. since there wont be stack overflow till all the computer resources gets exhausted.
    
Why the length of heap memory address is smaller compared to stack memory address ?

    This could be because(can be different in different arch) of positioning of stack and heap in memory architecture.
    Generally stack is initiated at higher memory location and grows downwards.. so it has higher memory address.
    Where as heap is initiated at lower memory and grows upwards.. so it has relatively lower memory address.. so the length of address is less.	
	
Difference between string and char array?
	String is a class and its identifiers are objects      -   Char array is an array datatype and identifiers are variables
	String needs header inclusion ie <string>	       -   It comes inbuild
	String is slower to access			       -   Char is faster to access
 
 

 

Can we do this?
     int &r = 3;   
        // No we cant directly assign number to reference
     int &x = foo();  where foo it returns as follows return p;
        // No it is returning value directly not variable p so we need to catch it with a variable
     int j = foo();
     int &y = j 
        // Yes, we can do as variable is assigned to reference  
 


How to handle variable length arguments in c++?
    #include <cstdarg>
    function(int no_of_arguments,...){}    
    va_list v;
    va_start(v,no_of_arguments)
    In for loop iterate : va_args(v,int)    
    va_end(v)

What is inline function?
    Whenever a function is called it will save the memory of function call
				  it will create a stack frame create local auto variables in stack
				  copy the contents of the function call
				  store the value to return in registers
    So this is a big overhead to OS, more importantly if context switching(stack func call) will take more time than time which it takes to execute
    So to reduce this overhead, compiler may copy the contents of inline function at the place of function call
    Bt compiler may not like i if it has follows
	the inline function has loops
	contains static variables
	recursive
	contains switch/goto

    But if func calls are more due to copying.. executable binary may become big
    compilation will take time
   
Use g++ -std=C++11 to compile code according to c++ 11 standards.. gcc version 4.8
   
Linker combines multiple object files of seperate programs along with dynamic link libraries in command line and link them
   
A global object is creatd calling another function(constructor) even before main() call.
	can also be done by static member of class refer cppnuts

Application of union is when we dont know which datatype is to be saved of a uniion object
Union may have abstraction and encapsulation cannot have inheritance and polymorphism i.e virtual functions 

A friend class can be placed at any point of the class it can be in private,public,protected.

Whenever an try block encountered an exception.. it will destruct/free all its resources (of try block) and then proceed to catch statment

No casting is requited if pointer to base class is pointing to derived class object 
    Base *b = new Derived;
But casting is required if pointer to derived class is pointing to base class object
    Derived *d = (Derived*)&b3;

	
	
What are smart pointers?

What are different types of constructors ?
	conv,explicit,move,copy,param,default

	
What is the difference between thread and a process?

	Process										Thread
	
	Process is heavy weight						Thread is light weight
	Process is part of application/program		Thread is part of a process

	Creation of process will take more time		Creation of thread will take less time
	Deletion of process will take more time		Deletion of thread will take less time

	Process will have its own memory			Thread will share the process'es memory
	So Cost of process comm will be more		So Cost of thread comm will be less
	
	if one process halts all other next process If one thread halts all other next threads will not be halted
	will be also halted						
	Hence more prefereble for CPU bound tasks	Hence More preferable for I/O user tasks
	
	

What is Multi threading?
	A thread is a light weight process.i.e a part of process which can be executed individually.
	Threads provide parallism and concurrency
	Each thread will have its own stack and can share memory space. i.e threads can run individually but not independent like process
	
	Eg : Mozilla firefox tabs are threads..
	     Internet explorer tabs are process
	
	No. of threads is calculated as follows :
	           1 core -  2 threads
			   i3 -  4 threads (i3 contain hyper-V)
			   i5 -  4 threads (i5 do notcontain hyper-V)
			   i7 - 4-7 cores 

    Note : Since thread can share common data in common address space there is no need such as IPC
           Given a single core MP, though the process have multiple threads each thread will run concurrently but not parallely i.e timely context switching takes place
              while there is a way around.. i.e A process containing multiple threads.. can be split accross mltiple cores(only if available) in such circumstances parallel processing is possible. 
		   where as multiple processess can run simultaneously in multi core processors. i.e one process in one core and another process in another core run parallelly i.e no need of context switching
             			


						

What are the synchronization primitives in multithreading?
    1. Mutex
	2. Semaphore



What is the difference betweeen lock and mutex?

lock is an object which encapsulates a lock i.e restrict access
mutex is a synchornization object which can implement a lock.
    i.e to implement a lock on mutex we have to provide a mutex as parameter
	
	Eg :  std::mutex m,
          std::lock_guard<std::mutex> lockGuard(m);
	
	
What are the different ways to create a thread?

What is the difference between user space and kernel space?
	Kernel space is a memory in OS where code of OS/kernel is stored.It does have low level program to maintain OS functions eg : restart,process tables etc..
	User space is a memory which is available for user applications. they do not have complete access to kernal space but a small access for system calls
	where as kernal space have whole access of memory i.e kernal space + user space
	
	Eg : A simple example is memory in mobile.. there is some space reserved for android/ios OS which we can access/modify/erase
         So apart from that OS space.. all ther remaining is user space


What is a a system call?
	A call which is made to provide interface/requests between program(process) and operaing system(kernel)
	Eg : endl calls flush() which is a call to OS, an example of system call
	     creation and management of process/thread
		 malloc/calloc/free etc are system calls
		 exit() - after this call.. OS will reclaim the resources used by the process
		 
		 wait(),fork(),exec(),kill(),exit()

What are the ways we get segmentation fault?
	1.trying to modify a read only access memory 
	        i.e char *s = "Hello"; *s = 'H';
			
	2. trying to modify a memory which is not allocated in stack during inititalization
			i.e arr[10] = {0};arr[14] = 3;

    3. When trying to access a wild pointer.
		    i.e int *p; cout << *p;
			
	4. When using scanf improperly.
			i.e scanf('%d',p)   // here we are not passing '&'
			
	5. Stack overflow :
			int main(){main();return 0;}   // infinite loop
			

What is Thread Control Block?
A Thread control block is a block/table  which maintains the information of the threads created.
It holds the following info :
	* Thread ID		*Thread State	*CPU information	*Thread priority	*pointer to process from where it is created  *prointer to other thread to which it created 

What is Process control Block?
A process control block is a table which maintains the information of the processess created
   * Pointer	* process state		* process number	*program counter	*register	*Memory list	*Open files	
		 
How do you do debugging in C++ application using linux
	1. Using gdb debugger - using core dump or via process id executing parallely 
	
	2. Using valgrind tool - using core dump or executing parallely
		valgrind ./executable --leak-check=full
		
		
How will you debug a code ?
	Debugging a code can be done via gdb debugger or valgrind tool..
	if the issue can be replicated in or local test servers.. then we can run the application via gdb debugger..
	if this is the case then we can execute the program parallely.. using various commands we can find where we are getting segmentation fault.
	or if the application is replicated in customer server.. such that we dont have accesss.. then we will enable the core dump in client server using below command
	    ulimit -c unlimited
	After which we will get a core dump file.. created in the same path.. we will take that file to our local.
	and analyze it under gdb debugger/valgrind tool
	
	If we use gdb debugger then the core file can be extraced this way : 
		gdb -c <core_file>
	
	
What is valgrind tool?
	A valgrind tool is a memcheck tool.. which provides the following functionalities.
		1. It provides memory usage especially heap memory
		2. It provides where there are leaks in the memory i.e number of blocks lost
		3. It provides the root cause of the segmentation fault/crash of the application

What is a core dump?
	A core dump is a file which is generated at times when application is crashed
	This core dump files help us to know the cause of the segmentation fault.
	The file can be loaded into gdb debugger/valgrind tool to analyze the root cause
	The significance of this file is.. that even though the application is deployed in customer environment we can analyze the root cause without replicating it again..
	This is also useful in conditions where we cant access the customer live server.In simple words, it acts like a log for segmentation fault 
	To enable core dump file use command "ulimit -c unlimited"  	 

What is a kernel?
	A kernel is the core part of Operating system. which deals as a mediater between software and hardware 
	It deals with memory on RAM/HDD,CPU,Devices
	
What are all the commands in gdb debugger ?
	next,n	step,s 	b,breakpoint	f <frame_num>	print,p	   info b   backtrace,bt	info locals  	

		 
What is a Daemon thread?

	The threads which are executing in background are called daemon thread.
	    Eg : garbage collector


How to make a thread wait until another thread completes?
	We can use join method to force one thread to wait for another thread to achieve this


Explain the following terms :
	Critical section
	Racecondtion
	Atomicity
	Deadlock
	Livelock
	conditional variable
	Spin lock
	Starvation

Critical section     : If two or more threads access a common part of code. that section is called critical section.
Race condition       : If two or more threads tries to modify a common shared resource in ciritcal section it is known as race condition.It leads to atomiciy
Atomicity            : It is a phenomenon during a race condition in which two threads modify a same common shared variable leading to undefined results

Deadlock 			 : If two threads are trying to gain access over the resource which is already locked by them 
                       Suppose t1 locks m1 and waits to gain/lock m2  at the sametime t2 locks m2 and waits for m1 to get released
					   The above situation leads to blockage where only rely on other.This is known as dead lock
					   
Livelock			 : 
	
Conditional Variable : This is a synchronization mechanism in which.. threads communicates regarding the state of the shared resource.
					   Once the condition becomes True.. it notify's all the sleeping(waiting) threads to have do its work(i.e to enter critical section)
					   Simple example is producer consumer problem.. thread which retrieve some thing from shared array(consumer) can be kept in sleep mode
					   and when producer adds something into shared array.. there will be a method to notify the sleeping thread to wake and do its work


Spin lock : A spin lock polls its lock condition repeatedly till the condition mets i.e till it become true to take its turn to access critical section.
			It is primarily used in the microprocessor where expected wait time is small
			Use a spinlock when you really want to use a mutex but your thread is not allowed to sleep.instead of sleeping it will continously try to check condition
					   


					   
What is Process scheduling and Process synchronization


What is the difference between mutex and semaphore?

              Mutex                                               Semaphore
	  
	   Mutex is a locking mechanism						Semaphore is a signalling mechanism
	  
  	   Mutex will provide ownership to only 			Semaphore can provide ownership to multiple threads
 	   one thread to critical section					provided it is a counting semaphore and not binary semaphore
	   
	   Mutex is an object 								Semaphore is an implementation via variable
	   
	   It has lock(),unlock() mechanism					It uses signal and wait mechanism
	   
    Difference in application : A mutex will only allow one thread to access critical section at a time..
	                            So if we have a buffer of 4kb to be produced by producer.. it should produce 4kb to be produced to give access to consumer thread
								Instead we can make buffer into 4 X 1kb buffer slots and allow both prodcer and consumer to access the buffer at a time



What are the different ways to create a thread in c++ 11?

Note : if we create multiple threads at a time, there is no gaurantee that which one will start first.
       i.e thread t1(fun,11);thread t2(func,12)  either t1 or t2 can be created first.


1. function pointer	 :    std::thread t1(fun, 11);
2. Lambda expression :    std::thread t1([](int x){while (x-- > 0){cout << "helo";}} )
3. functor			 :    std::thread t1(Base(),10)   // A class can be callable by operator overloading ()
4. Static member functions
5. non static member functions


What is join(),joinable(),detach() ?

join() : If forces one thread/program to wait till another thread completes and return after execution
joinable() : asking to join an already joined/completed thread will cause crash(terminate called()) to avoid that we can put a check
detach() : It is a counter part of join() i.e it will not make a thread to wait till another thread completes.i.e it will get detached with the thread

what is the way to make a thread sleep in c++ 11?
std::this_thread::sleep_for(chrono::seconds(4));

What are the different types of mutex available?

1. mutex
2. timed_mutex
3. recursive_mutex
4. recursive_timed_mutex
5. shared_timed_mutex


What is Static and dynamic linking?

Generally, when we want to use some functions/members of another file then we can include them as header files
BUt sometimes it may be necessary that, the header file needs to be included many files or we may find its application multiple times.So why not make it a library like we do in python(same concept as design pattern - reusability)
So such files are called libraries

                       Libraries
					   
					   
			    Static                  Dynamic
				
		Windows        Linux     Windows        Linux
		(.lib)         (.a)      (.dll)         (.so)
		
		
		.a  - archive
		.so - Shared object 
  


  So now what is static linking?
    linking of static libraries at compile time itself.. i.e during the linking stage... when combining all the .o files 
	
	Disad :
	
	Disadvantage is that since every library inclusion will copy its code in each file.. the final executable file will become large. Eg : stdio.h is widely used.. and if we static link it, it will copy everything then lenght will be more
	As the size of executable during linking increases.. loading also will take time
	Another disadvantage is that, if we change any thing in library file after compilation, then we need to recompile again..
	
	Advan :
	
	But the execution time will be reduced i.e runtime
	
	How to create static library?
	    ar rc liball.a dog.o cat.o bird.o
		(The “ar” stands for archive and it is used to create the static library. All the files ending in “.o” will be added to the liball.a library and they are the object files in this case.)
	
  So now what is dynamic linking?
    Inorder to avoid this, we dont have to include complete code of lib function. we can point to the library using pointer.and is only used at runtime (only when needed)
	
	Disad :
	But here the start up will be slow as it has to check if the library is already loaded in main memory via another file.
	
	Advan :
	
	As no need of copy, the executable size will be less.
	So faster loading
	if we change any thing in library afer compilation.. as it points to memoey where program is residing.. it will have latest changes

    How to create dyanamic library?
	gcc main.c -L l<file_name>

What happens if we throw an exception outside the try block?
	When we throw any exception outside try block.. then it cant have any catch block to handle exception.So in such cases it will call terminate().
	



Can we write continue in switch case

  No we cant write a continue in switch case since it is not a loop and will execute from top to bottom only once.. In general continue will skip next statements and go to next iteration.. which is not the case here. so no need of while loop
  It will yield error as follows :
      continue statement not within a loop

What happens if we dont have break statement in switch

If we dont write break in switch case.. it will go through all the case body's regardless whether case condition is met or not..
  But one thing to remember is the flow will be from the position where the case condition met till next break/default statement occured

    int choice = 1;
    switch(choice)
    {
        case 2:cout << "Hello 2" << endl;
        case 1:cout << "Hello 1" << endl;
        case 3:cout << "Hello 3" << endl;
        default: cout << "In default" << endl; 
    }

    O/P : Hello 1
	      Hello 3
		  In default
		  
What are DDL and DML commands?
What is truncate command?
What is an operating system

What is a dangling pointer
HOw to avoid dangling pointer
What is a memory leak
What is a smart pointer

What is a linked list
Difference between array and linked list

What is IPC

What is thread pool?
What is thread spawning?
What is context switching?
WHat is priority inversion?


What is Deadlock?

Acquiring a resource which is needed by another resource which inturn needs a resource which is hold by another resource is called deadlock situation

Eg : A acquires mutex m1 object and needs m2 object whereas B acquires mutex m2 and needs m1 object.



What are four conditions for deadlock to occur?

	Mutual Exclusion - The resource which the two threads/processess trying to access a resource must not be shareable
						if the resource is shareable then bothe can access and there cant be a deadlock
						
					   Eg : P1 acquires R1
                            P2 requires R1 so here R1 should not be shareable

    Hold and wait    - The process/thread involving in deadlock should atleast acquire one resource i.e hold and should wait for another resource.
                        Otherwise if the process release the previous resources then the other process can use it then there wont be a deadlock ofcourse releasing resources is one of the remedy to avoid deadlock
         
                        Eg : P1 acquires R1 and R2
                             P2 acquires R3, now P1 needs R3 but P2 is holding and waiting without release. so deadlock can occur

    

    No preemption    - The resource acquired should not be forcefully taken from process by OS.
                       Process itself should release then process will have only one chance to release the resource i.e when it completed its work	
						
						Eg : P1 acquires R1 
						     P2 also wants R1 so based on priority P2 should not be preempted and acquire resource forcefully
							 
    Circuilar wait   - General explanation of deadlock i.e traffic scenario
	
	

How to prevent dead locks?
	SImple answer is to prevent any of the above 4 condtions
	   i.e hold and wait/ no premption/ circular wait/mutual exclusion
	   
	care should be taken in the order of resource allocation.
	
	Don't request another resource while holding one resource.
	
	If you ever need to acquire two locks at once acquire locks in a fixed order.
	   i.e m1.lock();m2.lock() for thread 1         m1.lock();m2.lock() for thread 2
	   
	Don't wait for another thread if there's a chance it's waiting for you.
	Try to avoid holding locks for longer than we need to
	   i.e we can use timed_mutex


What are the ways to handle deadlock/deadlock recovery?

	1. Avoid deadlock : prevention is better than cure
						Make strategies in the code such that the system wont go into deadlock state

	2. Kill a process : This is easiest of all and it works but since once process is killed it has to restart its work
	3. Preemption     : We can take the resource forcefully from one process and give it to the other process requiring it (usually high priority)
	4. Rollback       : Here we will put a check point where we will record state of each process, in the code.. if we face a deadlock we roll back to last check point and restart.. but this time we will allocate resource differently so as to prevent reoccurence.
	
	
	

How to detect a deadlock?

	We can detect a deadlock via Resource allocatino graph..
	   i.e we have to check if there is any cycle in resource allocation graph.. (i.e normal deadlock example images are resource allocation graph)
       Now it has two chances if it detects a cycle in graph:
		if it has single instance - then yes it is deadlock
		       Eg ; R1 → P1 → R2 → P2.
		if it has multiple instance - though there is cycle it may not lead to deadlock

What is a livelock?
	A livelock is a special condition of deadlock..
		The primary difference between deadlock and livelock is the the processess inolving in a deadlock are put into wait/sleep state.
		whereas the processess involed in livelock is not put in wait state instead it will continously change their states making none of the processess involvved to progress

        Sometimes when a deadlock occurs then we may try to fix the issue and again we make changes/retry the attempt.. but again it fails such phenomemon is called livelock
		
	Eg : two mobile users trying to call each other at the same time will get engage
	     when they both stop/wait for each other anticipating other to call it is deadlock.. i.e here process are rude and want their work to be completed first
		 If they both try again in the sametime again they will get engage it is livelock.. i.e here process let other do their work
		 
		 In simple terms deadlock is single event livelock can be continous/infinite event
		 
    Another example is In dining philosophers problem... each philosopher will take a left fork and wait for right fork for five mins.
	    After 5 mins all the philosophers will put the left fork down trying to take right.. so now all will get right but all lefts are now taken up
		 SO it is a circuit problem
		 
How a block/waiting threads will be invoked when thread is waiting upon a lock to be unlocked?
	When a thread tries to acquire a lock on a mutex, if that mutex is already held then typically it will use a call to the OS kernel to indicate that it is waiting, 
	and then when t
	The same applies to a semaphore, except it only blocks if the count is decremented below zero, and threads are only woken when the count is increased back above zero.
	the thread that currently holds the lock unlocks the mutex then it will make a call to the OS kernel to wake one of the waiting threads.


What is a spin lock?
	A spin lock is a lock which continously polls upon the condition till the condition becomes true.
	So a spin-lock is implemented using busy-waiting.
	In this case the process are not kept in wait/hold state in contrary to mutex lock
	It is used in some critical application where we use ISR i.e in case of embedded systems
	It is generally used where expected wait time is less
	
	Note the difference between spin lock and busy waiting is that.. spin lock is implemented using busy wait mechanism..
	      as busy wait mechanism is a mechanism that which involes in a tight loop(continous loop) but no where it is related to lock
	
Difference between binary semaphore and mutex
What are thread synchronization mechanisms


what is the difference between mutex and semaphore
		        MUTEX															SEMAPHORE
		
    Mutex is a locking mechanism									Semaphore is a signalling mechanism
	So it has ownership over the resource							Id dont have ownership over the resource it acquired
	It allows only one thread/process to enter into CS				It allows one or more than one thread/process to enter into Critical Section 
	Only the entering thread shold open mutex lock					Any of the multiple thread/process can signal 
	Mutex is an object and required header							It is not an object it is just a code implementation
	A mutex cant be implemented as binary semaphore					A binary semaphore can be implemented as a mutex
	has lock/unlock mechanism										we have to write methods using if conditions <0
	Mutex provide priority inversion safety							Semaphore do not
	Mutex provide deletion safety									Semaphore do not
	
What is a monitor?

A monitor is similart to that of mutex/semaphore.. i.e it will allow one process to go through the section of code which it is monitoring
	
	
	

Difference between list and tuple,applications (i.e where we have to use)

How to access bits in a byte

	Using bitwise operators <<,>>,&,|,^,~
	We can do setting and unsetting a bit or toggling a bit using different bitwise operators using & and | logics

What are the difference between Little Endian & Big Endian processors
What is a copy constructor/Move constructor and its applications
Can we hae a pointer to register variable
Storage classes in C/C++
What are the differnces between structure and union
Where we can use union
Which STL container is better
What happens if vector/STL is there in copy constructor
Difference between auto and shared pointer
What are the differences between different types of pointers
Why the size of list is more than that of a tuple
What is the difference between string of C++/string of python
What is the primary difference between C++ and python
If we put static in header file and is included in some source file will it be same address in each of file.. or seperate i.e change in one will affect another?
if we have same param but we expect different return type what should we use? 
why we want copy constructor if we can do it via assignment operator?
Why to go for vector if deque can add elements at beginning and end at O(1)
