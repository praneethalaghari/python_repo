Playing with logics :

Find if a string can be made into a palindrome or not :
	
	for a even length string - occurences of each character should be even number
	for an odd length string - occurences of each character should be even number and there can be one odd repetitive character
	

Find number of pairs which equals sum 'n' in a given array :
	
	O(n) - for each element maintain a dictionary(map) 
	       if the element is there in keys of map then increment pair by 1
		   if the element is not there in key of map then create an entry in map where key is difference to the sum and value - index of the number 
	
	Eg : a = {3,1,6,9,4,3,7}  sum = 10;
		 map = {7:0 ; 9:1; 4:2}   // This mean index at 0 is lagging by 7 units..
		 So when traversed to 7 in array.. it will check if current number is there in keys of map.. if yes count++ else do 3:6
		 
Number of subarrays that can be formed in a given array of size N is N*(N+1)/2


Find the maximum sum of contigous subarray in a given array : 

Kadane's Algorithm :

    We will maintain two variables : curr_sum and max_sum;
	curr_sum will be incremented in cumulative manner iterating through the array..
	  if curr_sum < 0 then make curr_sum = 0 again.
	Update the max_sum whenever curr_sum > max_sum;

    Eg :             8  -7  -3  5  6  -2  3  -4  2
         curr_sum    8   1   0  5  11  9  12  8  10
         max_sum     8   8   8  8  11  12 12  12 12

         Here when we do 1-3 during 3rd iteration it results in -2 which is <0 so curr_sum should be made to 0
         every time compare if curr_sum > max_sm if yes update the value  		 

    Note : Kadane's algorithm will only work if it have atleast one positive integer.. i.e all negative values will give output as 0; which will be false.It is mentioned in wikipidea
	       If all negatives then.. since adding of two negative numbers will always result in further negative value.. we can go with max_element function to find the greatest.. the output will be a single element though