
Constructor :


	Special class function
	All the methods of parent class can be inherited but constructor cannot be inherited. 
    if we create a global object/static object of a class i.e outside any function even main().. then constructor of that objects class is called even before main()
	Destructor of such objects i.e global/static class will be called after main execution as the lifetime of such objects is end of program
	
Private :
    If a constructor is private.. objects cant be instantiated directly.
	But still the objects can be instantiated via a friend class constructor, as friend class can access private member.
	Applications : Singleton class,Interface,Named constructor

Static  :
	A constructor cannot be static in C++;
	As constructor is used to instantiate objects.. a static constructor is meaning less.
	But a specific object can be instantiated using static object and static method i.e singleton class
	But static constructors are possible in Java,C#

Virtual :
	A constructor cant be overridden, it is meaningless to have a constructor virtual.
	C++ is statistically typed, so object type should be determined at the time of compilation not dynamically.
	As custructor is where virtual table is defined
	So virtual before construtor will throw an error 

Pure virtual :
	As virtual constructor itself is not possible.There is no point of pure virtual constructor

final :
	All members of parent class can be inherited except constructor, so there is no need of final.
	
const :
	C++ dont have constant constructors
try_catch :
	if there is an exception in try block of constructor.. the object is considered uninstantiated i.e as it is not constructed completely
	So destructor wont be called

Inline :
    Yes Inline is possible with constructor. if compiler decides to inline it can place at object creation.
	But as it is just a request, if there are any virtual functions in constructor the constructor wont be inlined

friend :
	A constructor cannot be friend because, if it makes it is similar to some other class inheriting its constructor
	which is meaning less.
	
	
	
	
	
Destructor :

	Along with deleting dynamic memory allocation and stack(automatic) variables it is also used to clear up mutex and locks as well
	As Destructor dont contain parameters at all.. it cannot be overloaded.. and hence a class can have only one destructor
	Note that destructor is called only at the normal exit i.e when exit is called.. not Abort
	Global variables are destroyed in the opposite order of how they were created


Private :
  
    Yes a destructor can be private.
	If a destructor is private then the calss cannot be instantiated similar to constructor.(But wait iw can instatiate dynamic objects)
	Though the objects creation is not possible.. it is still possible to create pointer and create object in dynamic memory.
    So as far we dont use delete it will work fine but once delete is called.. it will go for destructor but since it is private it will throw error	
	

Static  :

	If destructor is static.. then it will somehow become a class method or static method...
    We know static method can only contain static variables/members
	but destructors are related to objects.. so it is not possible
	
Virtual :
	Yes a destructor can be virtual.
	This is very useful in dynamic polymorphism
	i.e when a base class pointer is pointing to some derived class object.. and if we delete the pointer then derived class objects contructor will be called only if base class destructor is virtual.

Pure virtual :
	Yes a destructor can be pure virtual .. but unline a pure virtual function. it is not an empty fucntion
	it will contain some body..
	because since destructor are called in the reverse order of constructors if there is nothing in the body of pvd it is of no meaning

final :
	As constructor, destructor cant be final. As we know that.. constructor and destructor are not inherited by derived classess 

const :
	No a destructor cant be const.. thers is no provision like such in c++ till now

try_catch :
	When a destructor contains try catch and if exception is thrown and caught then no problembut 
	But cannot be caught then always throw will call terminate() 
	During stack winding up if exception is caught it will terminate
	SImple answer to this question is.. destructor in C++ 11 is no except function i.e if any exception comes it will call terminate() directly to prevent exception propogation
	
friend :
	
	
	
Function :

Private :
	If a function is private in a class it is called utility class.. which is accessible to only other member function of the class or friend class

Static  :
	A static function is a class function which defines the state of a function. A function declared static can only have static variables inside
	i.t a static function will not contain non static variables
	static functions are called via scope operator and can be called via class name
	A static function can be called even though class has no objects
	useful in design patterns ex : singleton class
	An object of a class can be static similar to that of a static variable
    Even the normal objects of the class can also access static functions like any other functions
	
Virtual :
	This is the base of dynamic polymorphism.
	Any method of the class is declared virtual then it can cause dynamic polymorphism.
	It will create vptr and vtables of all the base and derived classes
	virtual function mean the function can be overridden

Pure virtual :
final :
const :
	if an object is made constant then it cant access non constant function.i.e it can only access constant functions only
try_catch :
friend :




Virual Function :

Private :
	     if a virtual function is private then dynamic polymorphism is not possible
         if the fucntion to override i.e derived class function is private then dynamic polymorphism is possible i.e override is possible
		 if constructor of base/derived is private in virtual it displays compiler error saying use of deleted function
		 private or virtual inheritance will cause compiler error
		 if the virtual function is not overridden.. there will be no dynamic polymorphism i.e it will call base class method only
		 This is similar to inheriting the virtual function into the derived class both are same
Static  :

Pure virtual :
		  This will make the class as interface ie abstract class
		  An abstract class cannot be instatiated
		  Make sure that the derived class should override the PV function as not doing so will make derived class also abstract

final :
		  if we declare the virual function as final then it cant be overridden or inherited i.e polymorphism fails
const :
try_catch :
friend


Note : if a virtual function is not overrided in derived class.. i.e if it is not redeclared.. then it will call base class function (according to vtable matching)
       if a virtual function is overrided but the method is private in derived class then it wont be a problem.. if will call like in normal cases
	   But the reverse is not possible i.e if the virtual function is private in base class then it will generate compiler error. since if base class virtual function is private then override is not possible


Variables :

Volatile :
Mutable :
Const :
static :
friend


Class :

private
static
const
final
pure virtual:
friend





Copy constructor
Default constructor
Paramterized constructor

Operator overloading

Static polymorphism
Dynamic polymorphism

This pointer

Public,private,protected inheritance,virtual inheritance :



Static :
  
    A static variable is stored in Data segment of Program memory layout.
	A static variable is by default inititalized with 0.
	A static variable can only get initialized by a constant not a variable or function in C. where as in c++ it can be initialized via function also.
	A static variable should not be used in structure in C, because variables in structure should be in contigous and located in same memory 
	   where as it is possible to have static variables in a struct/class in C++
	A static variable can be global,local or a data member
	  If a static variable is global 
	       - it need not be initialized but to derefer use ::var.
      If a static variable is local:
		   - it need not be initialized we can print like normal var.
	  If a static variable is data member of class :
		   - It should not be initialized where it is declared.
		   - It should not be left unitialized (i.e it should be initialized outside the class using :: operator)
		   - While declaring out of the class dont use static keyword again


	  class A{
		  public :
		  static int k;  // static int k = 4 - Compilation fails   
		};

		static int g=7;

		int A::k =3;     // static int A::k = 3 - compilation fails

		int main()
		{
			static int i=4;
			cout << i << endl;
			cout << A::k << endl;
			cout << ::g << endl;
			return 0;
		}

		
		
What is the difference between static and global variables?

	The primary difference betweeen the two is that..   static variable has a scope in which it is defined
	                                            whereas global variable has a scopt through out the program
												
Can a global variable be static?  (or)
What is the difference between global variable and static variable declared in global(i.e outside of any scope)

    Yes it is possible to have global variable as static.. i.e scope of the global variable will be limited to only that C file in which it is declared
	                 if we want the global variable to get accessed accross other .C files then dont declare a global variable as static

					 
What is the difference between copy constructor and assignment operator ?
	A copy constructor is called when there is no existing object created but to create a new object with object we want to copy.
	   Eg : Base b1(b2);
	   
	An assignment operator is called when we already created an object but is assigned/unassigned.. and we want to copy the contents into new ones
	   Eg : Base b1;
	        b1 = b2;
					 


*************************************************************************************************************************************
					 
Along with pointers we can also modify the private variables out side the class via references as shown below :
					 
					 
#include<iostream> 
using namespace std; 

class foo
{
    int a,b;
    public:
    int& vala(){return a;}
    int& valb(){return b;}
    void show(){cout << this->a << this->b << endl;}  
    
};

int main() { 
  foo f1;
  f1.vala() = 4;
  f1.valb() = 6;
  f1.show();
  
  return 0; 
}

*************************************************************************************************************************************
					 
What is copy elision?

Elision means ommision i.e it will prevent unnecessary copy of objects
It is similar to that of conversin constructor


Copy elision will prevent the overhead of calling copy constructor.
It depends on the type of compilers we will use.


For Eg : 


#include <iostream> 
using namespace std; 
   
class B 
{ 
public:     
    B(const char* str = "\0") //default constructor 
    { 
        cout << "Constructor called" << endl; 
    }     
      
    B(const B &b)  //copy constructor 
    { 
        cout << "Copy constructor called" << endl; 
    }  
}; 
   
int main() 
{  
    B ob = "copy me";  
    return 0; 
} 

Here if the compiler dont use copy elision :

   then B ob = "copy me"  is interpreted as B ob = B("copy me")
   i.e first it will create a temporary object(calls constructor) and then uses copy constructor(calls copy constructor) to copy into 'ob' object.
   
   where as modern compilers(usually use copy elision) will break down the statemnt to :
   B ob("copy me")
   So it will only called constructor and no copy constructor will be called.Here creation of temporary object and copy is merged.

					 